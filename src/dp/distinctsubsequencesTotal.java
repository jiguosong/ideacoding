package dp;

public class distinctsubsequencesTotal {
	// how many ways to remove some characters (>= 0) from S to get T?
	public int numDistincts_based_on_model(String S, String T) {
		if(S == null || T == null) return 0;
		int m = S.length();
		int n = T.length();
		
		int[][] ways_to_change = new int[m+1][n+1];
		for(int i = 0; i <= m; i++)  ways_to_change[i][0] = 1;
		
		for(int i = 1; i <= m; i++) {
			char c1 = S.charAt(i-1);
			for(int j = 1; j <= n; j++) {
				char c2 = T.charAt(j-1);
				// idea: j (that is same as i) can be generated by remove in i-1, or it already automatically matches i (i++, j++ for say)
				if(c1 == c2) ways_to_change[i][j] = ways_to_change[i-1][j-1] + ways_to_change[i-1][j];
				// idea: j (that is different as i) can only be generated by remove in i-1, and cannot automatically generated matches
				else ways_to_change[i][j] = ways_to_change[i-1][j];				
			}
		}
		
		return ways_to_change[m][n];
	}
	
	public int numDistincts(String S, String T) {
		if(S == null || T == null) return 0;
	
		int m = S.length();
		int n = T.length();
		
		// dp[i][j]: the number of occurrence of substring T(0,j) in substring S(0,i)
		int[][] dp = new int[m+1][n+1];
		for(int i = 0; i < n; i++) {
			dp[0][i] = 0;
		}
		for(int i = 0; i < m; i++) {
			dp[i][0] = 1;
		}
		
		
		for(int i = 1; i <= m; i++) {
			for(int j = 1; j <= n; j++) {
				if(S.charAt(i-1) == T.charAt(j-1)) dp[i][j] += dp[i-1][j-1] + dp[i-1][j];
				else dp[i][j] += dp[i-1][j];
			}
		}
		
		return dp[m][n];
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		distinctsubsequencesTotal test = new distinctsubsequencesTotal();
		String S = "rabbbit"; String T = "rabbit";
		int ans = test.numDistincts(S, T);
		System.out.println(ans);
		
		ans = test.numDistincts_based_on_model(S, T);
		System.out.println(ans);

	}

}
